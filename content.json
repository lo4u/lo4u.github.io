{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/05/28/hello-world/"},{"title":"脱壳系列1.md","text":"逆向之旅-脱壳系列 写在前面： 本文主要讲解如何手动脱壳或应对一些难以脱去的壳 由于博主知识有限，也不能很好地对其中一些方法做更深入的知识，以后有空来重制一下这些文章吧 脱壳系列1 入门级 本篇只做入门介绍，不涉及加密壳，对于通常的压缩壳及其变形壳，基本都是完全将程序解压缩出来以后再运行，部分壳会带有一些反调试策略，也可能碰上程序带有附加数据的情况。 方法总览： 堆栈平衡原理，或者叫esp定律法，对于这种先全部解压在运行的程序很好使，在程序开始时首先会将寄存器中现有的数据压入栈中，然后开始压缩过程，随后在解压完成之后pop出来，这个pop是相当于对栈中相应位置进行了一个访问操作，所以只需要对该位置下入硬件访问断点即可。 二次内存镜像法：也是运用了一部分壳的运行规律，这类壳通常自己解压壳的代码在另一个区段，会首先访问.rsrc区段读取资源，然后在解压完成后跳转到.text段继续执行代码，此时即是解压完成了。在这两个区段下入相应内存断点即可。这个顺序不能乱，直接下入.text段是不可以的，是因为运行过程中被修改了吗？似乎还会碰到exception_access_violation异常，意味着试图访问受保护的内存。 最后一次异常：程序脱壳完成后，开始执行用户代码，此后一般不会碰到异常，通过到最后一次异常处停下来，此时栈区有一个se句柄的内容，跳转到该地址，运行至该处，再接着单步，可以快速到达真实oep。（忽悠人的吧，博主用x32/64dbg没见着过se句柄） 自动跟进，采用一定条件使用自动单步步入就可以了，条件可以使用堆栈平衡、或者执行到.text段等等（即寄存器的值）， 和人手单步走类似，但由于调试器不会自动判断应该步进还是步过，所以为了防止跳过，只能一直步入，这种方法很慢，可能会半小时，大概步入300万步。 首地址，有些壳入口点处会出现 mov eax,inc2l.40AB5C这种汇编指令，这时后面这个地址通常是更靠近真实oep的，可以在该处下断点，然后运行到停止，再单步走。这个地址似乎每次都和最后一次异常法中的se句柄地址一样。！？ 特殊指令或函数：比如popad、VirtualFree、VirtualAlloc等函数，还有push 0x8000这类特征码，此方法需要经验和一定了解程度。在跨模块调用窗口中的内容均是调用，不一定会通过你查到的方式调用，所以直接使用bp VirtualFree的命令更方便，直接将断点直接下载函数入口位置，也就是调用后的位置，在call的位置回车进入也能看到。 原理共通，其实都是通过一些办法接近oep，有些办法能直接到oep，而有些办法则只能趋近，此时需要再人手单步走一段，所以理论上全程单步步过也可以。针对这类解压完后再运行的壳还是非常简单的。 接下来用实例来说明这些方法的使用 注意下入的断点删除后dump 实例 upx3.91 载入x64dbg，并运行至EP处，如下 此时停在了解压过程的开始的位置，这里出现了一系列的push指令， 可以在当前区域随意搜索，发现pop rbp指令只有一个，运行到对应位置： 图上一个灰色标出的即是刚才搜索的pop rbp指令，单步几步后就到了下面的jmp无条件 跳转指令，这里是个很大的跳转，过去就是OEP了。 目光回到上一张图，即原始ep处，此时的ESP是000000000061FF28，毫无疑问当脱壳完成后ESP会回到这里。利用此堆栈平衡原理，可以引出两个办法，其一，单步走一步，此时栈中压入了rbx， 在该内容处下入硬件访问断点，断点大小取啥都无所谓，当执行到结束时的pop rbx时将触发这个硬件断点： 再次按下F9即可到达脱壳完成时的位置，此时删除硬件断点，单步几步后即可到达OEP处 其二，使用步入追踪功能，条件设为ESP == 0x61ff28，这个方法相当慢，不推荐，就这个简单程序博主跑了半个小时才跑到对应位置。 这个简单的壳一直单步步过也可以快速脱壳，只需要注意单步步过的原则：向上跳转则运行至下方选中代码，若直接跑飞则再重来步入相应函数。 二次内存镜像 博主已经看过pe信息了，挑重点说。 直接x32dbg载入NotePad.exe， 进入内存布局页面，如下： 显然是aspack壳。 这里第一部分就是该程序的块表，在下方还有各种dll的块表，那个不需要关注。首先运行至EP处，在.rsrc段下入内存访问断点，F9运行，到达0x40D75F处，再在.text段下入执行断点，再次F9运行，将直接来到OEP处，此时可以直接脱壳。 特殊函数、首地址方法 载入inc2l.exe，运行至EP处： 第一行出现了一个重要地址：0x40AB5C， 直接bp 0x40AB5C， 在该处下入软件断点后，F9运行至该位置，接下来不断单步运行，当遇到ret指令时，视作向上跳转的jmp处理，即直接F4运行至下方代码，不断运行，可以到达OEP处，该方法不是很推荐，因为显然之后的单步过程稍长，容易把人转晕。 采用特殊函数的办法的话则方便得多，直接使用bp VirtualFree命令，下入断点（跨模块调用中搜到的VirtualFree函数，直接下入断点只是在其call处下断点，并不是函数处下断点，需要回车进入所call的地址下入断点，建议直接使用bp VirtualFree命令，只是要注意区分大小写） F9运行至函数入口处，再运行回到用户代码（ALT + F9），此时可以选择单步，也可以采用直接搜索特征码push 0x8000并运行至该处的方法。 下面的ret处就很接近OEP了。 修复IAT如果自动搜索不全或者有错误函数，就需要人手处理了。如一开始的UPX壳： 选取任意正确的函数，查找到IAT的位置，在插件扫描到正确的函数列表中找一个，或者在汇编指令中找一个都行。如下： 上图是开头位置，下图是末尾位置 插件窗口中已自动填入了开始位置VA，我们修改一下size：0x40836C + 8 - 0x4081DC = 0x198，并填入，重新Get即可发现没有错误函数了。修复刚才的转储文件，惊喜地发现程序已经可以跑起来了。 处理附加数据附加数据实际上就是提供给该程序一个读取的对象，并将两者捆绑，这意味着一个原本会要求你选择一个文件来操作的程序，现在打开后会直接对末尾的附加数据操作并返回结果，而不需要你来提供文件。 不被归于某个块表中的pe文件末尾的数据便是附加数据（overlay），不会被映射到内存中， 且读取这块内存时程序使用的是相对偏移，因此只需要将整块的附加数据复制到转储并修复的文件最后即可（用16进制editor）。 一般情况都可以解决，毕竟在ctf中，碰上附加数据的情况很少。 由于内存对齐机制的存在，找到整个Overlay段落还是很简单的，在程序末尾与前边的内容用大量00填充分隔的便是Overlay了。 文中的例子： 链接：https://pan.baidu.com/s/18J3fAf3vfMM__mbxH-B5rA?pwd=lo4u提取码：lo4u","link":"/2024/05/28/%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%971/"}],"tags":[],"categories":[],"pages":[]}